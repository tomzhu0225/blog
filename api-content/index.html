{"posts":[{"title":" associated code for Use the XY mode of oscilloscope to draw graphs with audio signals","content":"picture processing ''' MIT License Copyright (c) 1998-2021 RIGOL co.,ltd. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Vector WaveForm Converter Based On Python,OpenCV,Numpy Powered By Dave Xue ''' import cv2 as cv import numpy as np from numpy.core.defchararray import count from numpy.lib.function_base import append #Target Video Path and Name videoPaths = r&quot;C:\\Users\\tomkeen\\Desktop\\physicswriting\\bapiece.mp4&quot; #Images Output Path imgPaths = &quot;mc2.img&quot; #Quantity Of Points Per Frame ptsPerFrame = 10 #Prefix Of File Name Of WaveForm Output fileName = &quot;nonWFM&quot; imgShape = [] xData = [] yData = [] FrameCountEnd = 0 FrameCountStart = 1 #Converd Video To Images def v2p(videoPath, imgPath): global FrameCountAll videoObj = cv.VideoCapture(videoPath) frameCount = 1 saveCountDown = 1 saveCount = 0 if videoObj.isOpened(): rval, frame = videoObj.read() FrameCountAll = videoObj.get(cv.CAP_PROP_FRAME_COUNT) else: print(&quot;Video Err&quot;) rval = False while rval: rval, frame = videoObj.read() if (not rval): break if (frameCount % saveCountDown == 0): saveCount += 1 print(&quot;NOW Frame is &quot; + str(saveCount) + &quot; Of All Frame &quot; + str(FrameCountAll) + &quot; &quot; + str(100*(saveCount/FrameCountAll)) + &quot; % &quot;,end='\\r' ) cv.imwrite(imgPath+str(saveCount)+&quot;.jpg&quot;, frame) frameCount += 1 cv.waitKey(1) videoObj.release() #Use OpenCV To Find Contours In Each Frame def contours(image): dst = cv.GaussianBlur(image, (3, 3), 0) #Use Gaussian Blur To Against Noises gray = cv.cvtColor(dst, cv.COLOR_RGB2GRAY) ret, binary = cv.threshold(gray, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU) #Binaryzation The Image By OSTU c_canny_img = cv.Canny(gray,10,150)#Use Canny Algorithm To Find Edges cv.imshow(&quot;canny image&quot;, c_canny_img) contours, heriachy = cv.findContours(c_canny_img, cv.RETR_LIST, cv.CHAIN_APPROX_NONE)#Get Contours print(&quot;Find &quot;+str(np.size(contours))+&quot; Contours&quot;,end = '') cv.drawContours(image, contours, -1, (0, 0, 255), 2) cv.imshow(&quot;COU&quot;,image) cv.waitKey(2) return contours #Write Points Into Buffer def write2data(ptsList): global xData,yData ptsCount = 0 ptsloop = 0 xTmp = [] yTmp = [] for pts in ptsList: pts = np.transpose([pts]).tolist() for ptC in range(0,np.size(pts[0][0])-1): xTmp.append(int(((pts[0][0][ptC][0]/(imgShape[1]/2))-1.0)*65535)) yTmp.append(int(((pts[1][0][ptC][0]/(imgShape[0]/2))-1.0)*65535)) ptsCount += 1 if (ptsCount &lt; ptsPerFrame and ptsCount &gt; 0): ptsloop = int(ptsPerFrame/ptsCount) ptsCount = (ptsPerFrame-(ptsloop*ptsCount)) for i in range(0,ptsloop+1): xData += xTmp yData += yTmp elif(ptsCount &gt;= ptsPerFrame and ptsCount &gt; 0): xData += xTmp yData += yTmp else: xData.append(0) yData.append(0) print(&quot;pts: &quot;+str(ptsCount*ptsloop)) #Config File Names def contoursAll(imgsPath,filaName): global imgShape,FrameCountAll,ptL for i in range(int(FrameCountStart),int(FrameCountEnd)): ipath = imgsPath+str(i)+&quot;.jpg&quot; src = cv.imread(ipath) imgShape = src.shape ptL = contours(src) write2data(ptL) xFile = open(filaName+'zheshizhendx.txt', 'a', newline='') yFile = open(filaName+'zheshizhendy.txt', 'a', newline='') for i in range(np.size(xData)-1): xFile.writelines(str(xData[i])+'\\n') yFile.writelines(str(yData[i])+'\\n') xFile.close() yFile.close() if __name__ == &quot;__main__&quot;: print(&quot;Input Frame Num To Start From Images Or 'c' From Video&quot;) frame = input() if (frame != 'c'): FrameCountStart = int(frame) print(&quot;Input The End Of Frames&quot;) FrameTotal = int(input()) else: v2p(videoPaths, imgPaths) FrameCountEnd = FrameTotal contoursAll(imgPaths, fileName) ","link":"https://tomzhu0225.github.io/post/associated-code-for-use-the-xy-mode-of-oscilloscope-to-draw-graphs-with-audio-signals/"},{"title":"椭圆形船过水道问题","content":"本文使用CC-BY-SA-3.0协议，意味着：署名，相同方式共享，不设额外限制 ","link":"https://tomzhu0225.github.io/post/tuo-yuan-xing-chuan-guo-shui-dao-wen-ti/"},{"title":"使用示波器显示图片（视频）","content":"本论文本为物理实验改进的作业。本实验的想法源于自己的一些个人兴趣，是一直想做的事情，很多人已经使用了专业的信号生成器实现了在示波器上绘画图像，但是还没有人使用音频接口（3.5mm耳机接口）来生成图像，这次实验是对耳机（音频）产生原理的一次出色实践。由此产生了利用耳机接口来生成信号的想法。前几日完成了该项实验的基本任务，但是距离发表还有一段距离。自行购买了虚拟示波器，将在电脑上对该项实验进行更加详尽的测试，对示波器和音频使用何种参数可以得到最佳的图像进行探究。事实上要探究这种问题，实际上就是探索hyperparameter的取值，从原理来说完全可以使用梯度下降法对hyperparameter进行探究，我们只需要确定一个对示波器成像质量进行衡量的矩阵。注意本文使用MIT licence。 ","link":"https://tomzhu0225.github.io/post/shi-yong-shi-bo-qi-xian-shi-tu-pian-shi-pin/"},{"title":"画图软件使用指南&画图软件python代码","content":"将我的代码的一些冗余部分进行了删减。要正常运行该代码，首先需要pip本代码使用的库，或者直接下载anaconda的环境；其次主菜单启动图片的加载是载入记录在另一个py文件中的图片的base64编码的，若直接复制代码运行会出错，若要运行请将‘from memory_pic import *’删除，将get_pic函数删除并修改‘a=random.randint(1,3) name=&quot;bizhi&quot;+str(a)+'_gif' filename=&quot;bizhi&quot;+str(a)+'.gif' get_pic(eval(name), filename) photo = tk.PhotoImage(file=filename)’换成您的图片的绝对地址（只能是gif图片）， 软件主界面 画图软件运行后会出现该主界面。主界面的左上角是三枚菜单按键，其中设置菜单键，可设置画布的快捷键（该功能正在开发中）；单击帮助键，软件将打开浏览器跳转到该使用指南。 画图键 将鼠标移至画图键，出现下拉菜单，保存按键功能正在开发中。单击新画板，来新建画布。 单击新画板后系统出现弹窗。 在画布长度一栏中输入整数，设置画布x轴长度；同理在画布高度一栏中输入整数，设置画布y轴长度。该项数据默认为（1920，1080） 单击选择画布颜色键选择画布的背景颜色，此时系统会弹出系统默认的颜色选择框。若不进行选择，系统默认画布颜色为黑色。 点击画布设置框中的新建画布即可创建画布 画布界面 画布界面分为两个部分：浮动的工具栏和画布主体。 ** 须知工具栏总在窗口的最前端，且一但关闭只能重新新建画布 ** 工具栏 常规工具 对于画笔、矩形、椭圆（圆）、橡皮擦、直线、箭头直线工具，使用方法类似。在画布窗口点击鼠标左键并且不抬起，在画布窗口中滑动进行绘画，抬起鼠标左键绘画终止。 新建文本 单击新建文本后，弹出对话框，输入想打印的文本，单击确认。 后在画布界面，您想要插入文本的地方单击一次，并在画布的另一个位置单击另一次，插入文本的大小将根据两次单击的x轴距离进行相应计算，插入文本的中心与两次单击的连线中点的位置重合。 插入图片 单击插入图片，弹出系统文件选择框，支持高达4种的图片文件格式，选择图片文件后，系统弹出对话框 选择想要的图片比例后，单击插入图片后在画布上单击，单击位置即为图片插入的中心位置。 颜色 单击颜色文件选择颜色，该选项可以控制画笔、矩形、椭圆（圆）、直线、箭头直线、新建文本以及填充的颜色。默认画笔颜色为黄色。 清屏 删除画布上一切内容 右侧粗细选择滑动条 该选项可以控制画笔、矩形、椭圆（圆）、直线、橡皮擦、箭头直线的粗细。系统默认值为5。 选择 单击选择按钮后，单击鼠标左键并且拖动，进行框选，框选完成后松开鼠标左键，按住鼠标右键进行拖动改变选中内容的位置。 填充 在画板上有用**画笔**工具**一笔画出**的**闭合曲线**时，点击填充，在待填充曲线的内部，单击鼠标左键并等待，在填充颜色出现前不要移动鼠标。 注意：在填充前缩放画布可能会导致未知bug；在填充后，选择并移动被填充部位或者是缩放画布可能会异常卡顿 常用快捷键&amp;其他操作 缩放画布 鼠标滚轮滚动 撤销操作 键盘快捷键：CTRL＋Z 平移画布 在画布下侧和右侧分别有滚动条，当放大画布时，滚动条会出现滑块，此时可以进行画布的平移。 画笔颜色快捷键 键盘按键：ｒ 转换画笔颜色为红色。 键盘按键：ｇ 转换画笔颜色为绿色。 键盘按键：ｂ 转换画笔颜色为蓝色。 键盘按键：ｙ 转换画笔颜色为黄色。 import tkinter as tk from tkinter import messagebox from tkinter.colorchooser import askcolor from tkinter import * import random from memory_pic import * from base64 import * import ctypes import tkinter.filedialog from tkinter.ttk import * from os.path import exists import PIL.Image import os, sys import numpy as np import math from sklearn.cluster import KMeans import matplotlib.pyplot as plt import webbrowser #创建窗口，root可替换成自己定义的窗口 sys.setrecursionlimit(1000000) #重新设置栈空间 root = tk.Tk() #调用api设置成由应用程序缩放 ctypes.windll.shcore.SetProcessDpiAwareness(1) #调用api获得当前的缩放因子 ScaleFactor=ctypes.windll.shcore.GetScaleFactorForDevice(0) #设置缩放因子 root.tk.call('tk', 'scaling', ScaleFactor/75) col_1=(0,'#000000') width_b=0 height_b=0 global i #对于插入文本功能的全局计数器 i=0 win_width = 1000* ScaleFactor/100 win_height = 500 * ScaleFactor/100 class Application(Frame): &quot;&quot;&quot;一个经典的GUI写法&quot;&quot;&quot; def __init__(self, master=None): &quot;&quot;&quot;初始化方法&quot;&quot;&quot; super().__init__(master) # 调用父类的初始化方法 self.x = 0 self.y = 0 self.fgcolor = 'yellow' self.lastdraw = 0 self.start_flag = False self.master = master self.pack() self.createWidget() self.Tbar() self.start_flag_text= True self.thickness=5 self.stlist=[] self.w=None self.start_flag_pic=True self.start_fill=True self.coordsrect=[] self.chosenlist=[] self.j=0 self.penmarklist=[] self.pencount=0 self.pencountflag=False def createWidget(self): &quot;&quot;&quot;创建画图区域&quot;&quot;&quot; self.drawpad = tk.Canvas(self, width=width_b, height=height_b, bg=col_1[1]) self.drawpad.grid() self.drawpad.bind('&lt;ButtonRelease-1&gt;', self.stopDraw) # 创建按钮 self.xsb = tk.Scrollbar(self, orient=&quot;horizontal&quot;, command=self.drawpad.xview) self.ysb = tk.Scrollbar(self, orient=&quot;vertical&quot;, command=self.drawpad.yview) self.drawpad.configure(yscrollcommand=self.ysb.set, xscrollcommand=self.xsb.set) self.drawpad.configure(scrollregion=(0,0,1000,1000)) # draw self.layout() # This is what enables scrolling with the mouse: self.drawpad.bind(&quot;&lt;ButtonPress-1&gt;&quot;, self.scroll_start) self.drawpad.bind(&quot;&lt;B1-Motion&gt;&quot;, self.scroll_move) self.drawpad.bind(&quot;&lt;B3-Motion&gt;&quot;, self.movethechosen) #windows scroll self.drawpad.bind(&quot;&lt;MouseWheel&gt;&quot;,self.zoomer) def tocanvasxy(self, event): return int(self.drawpad.canvasx(event.x)), int(self.drawpad.canvasy(event.y)) def scroll_start(self, event): x, y = self.tocanvasxy(event) self.drawpad.scan_mark(x, y) def scroll_move(self, event): x, y = self.tocanvasxy(event) self.drawpad.scan_dragto(x, y, gain=1) def zoomer(self, event): x, y = self.tocanvasxy(event) if (event.delta &gt; 0): self.drawpad.scale(&quot;all&quot;, x, y, 1.1, 1.1) elif (event.delta &lt; 0): self.drawpad.scale(&quot;all&quot;, x, y, 0.9, 0.9) self.drawpad.configure(scrollregion = self.drawpad.bbox(&quot;all&quot;)) def layout(self): self.xsb.grid(row=1, column=0, sticky=&quot;ew&quot;) self.ysb.grid(row=0, column=1, sticky=&quot;ns&quot;) self.drawpad.grid(row=0, column=0, sticky=&quot;nsew&quot;) self.grid_rowconfigure(0, weight=1) self.grid_columnconfigure(0, weight=1) def scroll_start(self, event): self.drawpad.scan_mark(event.x, event.y) def scroll_move(self, event): self.drawpad.scan_dragto(event.x, event.y, gain=1) def cancel_1(self): self.quest_1.destroy() def cancel_2(self): self.quest_2.destroy() #创建悬浮工具窗 def confirm_1(self): self.text = self.text_w.get() self.start_flag_text= True self.quest_1.destroy() #画板外框宽 def confirm_2(self): self.quest_2.destroy() self.start_flag_pic=True def Tbar(self): def thicknessslider(v): self.thickness = v self.tbar=tk.Tk() self.menubar=Frame(self.tbar) #self.tbar.overrideredirect(True) self.tbar.attributes(&quot;-topmost&quot;, True) self.tbar.attributes(&quot;-toolwindow&quot;, 1) self.menubar.pack() self.slider = tk.Scale(self.tbar, label='粗细', from_=0, to=100, orient=tk.VERTICAL, length=500, showvalue=1,tickinterval=2, resolution=1, command=thicknessslider) self.slider.pack(side='right') self.btn_start = Button(self.tbar, name='start', text='开始') self.btn_start.pack(side='top', pady=10,ipadx=20) self.btn_pen = Button(self.tbar, name='pen', text='画笔') self.btn_pen.pack(side='top', pady=10,ipadx=20) self.btn_rect = Button(self.tbar, name='rect', text='矩形') self.btn_rect.pack(side='top', pady=10,ipadx=20) self.btn_oval = Button(self.tbar, name='oval', text='椭圆') self.btn_oval.pack(side='top', pady=10,ipadx=20) self.btn_circle = Button(self.tbar, name='circle', text='圆') self.btn_circle.pack(side='top', pady=10,ipadx=20) self.btn_clear = Button(self.tbar, name='clear', text='清屏') self.btn_clear.pack(side='top', pady=10,ipadx=20) self.btn_erasor = Button(self.tbar, name='erasor', text='橡皮擦') self.btn_erasor.pack(side='top', pady=10,ipadx=20) self.btn_line = Button(self.tbar, name='line', text='直线') self.btn_line.pack(side='top', pady=10,ipadx=20) self.btn_line_arrow = Button(self.tbar, name='line_arrow', text='箭头直线') self.btn_line_arrow.pack(side='top', pady=10,ipadx=20) self.btn_color = Button(self.tbar, name='color', text='颜色') self.btn_color.pack(side='top', pady=10,ipadx=20) self.btn_text=Button(self.tbar,name='text',text='新建文本') self.btn_text.pack(side='top',pady=10,ipadx=20) self.btn_pic=Button(self.tbar,name='pic',text='插入图片') self.btn_pic.pack(side='top',pady=10,ipadx=20) self.btn_cho=Button(self.tbar,name='choose',text='选择') self.btn_cho.pack(side='top',pady=10,ipadx=20) self.btn_fill=Button(self.tbar,name='fill',text='填充') self.btn_fill.pack(side='top',pady=10,ipadx=20) # 绑定事件 self.btn_line.bind('&lt;Button-1&gt;', self.eventManager) # 点击按钮事件 self.btn_line_arrow.bind('&lt;Button-1&gt;', self.eventManager) # 点击按钮事件 self.btn_rect.bind('&lt;Button-1&gt;', self.eventManager) # 点击按钮事件 self.btn_oval.bind('&lt;Button-1&gt;', self.eventManager) self.btn_circle.bind('&lt;Button-1&gt;', self.eventManager) self.btn_pen.bind('&lt;Button-1&gt;', self.eventManager) # 点击按钮事件 self.btn_erasor.bind('&lt;Button-1&gt;', self.eventManager) # 点击按钮事件 self.btn_clear.bind('&lt;Button-1&gt;', self.eventManager) # 点击按钮事件 self.btn_color.bind('&lt;Button-1&gt;', self.eventManager) # 点击按钮事件 self.btn_cho.bind('&lt;Button-1&gt;', self.eventManager) self.btn_fill.bind('&lt;Button-1&gt;', self.eventManager) self.master.bind('&lt;KeyPress-r&gt;', self.hotKey) # 绑定快捷键 self.master.bind('&lt;KeyPress-g&gt;', self.hotKey) # 绑定快捷键 self.master.bind('&lt;KeyPress-b&gt;', self.hotKey) # 绑定快捷键 self.master.bind('&lt;KeyPress-y&gt;', self.hotKey) # 绑定快捷键 self.master.bind('&lt;Control-z&gt;', self.callback) self.btn_text.bind('&lt;Button-1&gt;',self.eventManager) self.btn_pic.bind('&lt;Button-1&gt;',self.eventManager) # 左键释放按钮 def eventManager(self, event): name = event.widget.winfo_name() print(name) self.start_flag = True if name == 'line': # 左键拖动 self.drawpad.bind('&lt;B1-Motion&gt;', self.myline) self.pencountflag=False elif name == 'line_arrow': self.drawpad.bind('&lt;B1-Motion&gt;', self.myline_arrow) self.pencountflag=False elif name == 'rect': self.drawpad.bind('&lt;B1-Motion&gt;', self.myrect) self.pencountflag=False elif name == 'oval': self.drawpad.bind('&lt;B1-Motion&gt;', self.myoval) self.pencountflag=False elif name == 'circle': self.drawpad.bind('&lt;B1-Motion&gt;', self.mycircle) self.pencountflag=False elif name == 'pen': self.drawpad.bind('&lt;B1-Motion&gt;', self.mypen) self.pencountflag=True elif name == 'erasor': self.drawpad.bind('&lt;B1-Motion&gt;', self.myerasor) self.pencountflag=False elif name == 'clear': self.drawpad.delete('all') self.penmarklist=[] self.pencountflag=False self.pencount=0 elif name == 'text': self.quest_1 = tk.Toplevel() self.quest_1.title('请输入文本') self.quest_1.geometry('300x150+800+500') self.text_w = tk.StringVar() self.text_w.set('插入文本') self.pencountflag=False #tk.Label(quest, text='画布长度 ').place(x=20, y=20) self.entry_text = tk.Entry(self.quest_1, textvariable=self.text_w) self.entry_text.place(x=10, y=20) self.confirm = tk.Button(self.quest_1, text='确认', command=self.confirm_1) self.confirm.place(x=100,y=70) self.cancel = tk.Button(self.quest_1, text='取消', command=self.cancel_1) self.cancel.place(x=200,y=70) self.drawpad.bind('&lt;Button-1&gt;', self.createtext) elif name == 'pic': def rat(b): self.ratio=b self.fn=tkinter.filedialog.askopenfilename(title='选择一个图片', filetypes=[('bmp文件','.bmp'),('gif文件','.gif'),('jpg文件','.jpg'),('png文件','.png')]) self.quest_2 = tk.Toplevel() self.quest_2.title(&quot;插入图片大小&quot;) self.quest_2.geometry('400x200+800+500') self.scalpic=tk.Scale(self.quest_2, label='图片比例', from_=0, to=1, orient=tk.HORIZONTAL, length=320, showvalue=1,tickinterval=2, resolution=0.01, command=rat) self.scalpic.pack(side=&quot;top&quot;) self.file_path = self.fn confirm = tk.Button(self.quest_2, text='插入图片', command=self.confirm_2) confirm.place(x=50,y=130) cancel = tk.Button(self.quest_2, text='取消', command=self.cancel_2) cancel.place(x=200,y=130) self.drawpad.bind('&lt;Button-1&gt;', self.putpic) self.pencountflag=False elif name == 'color': c = askcolor(color=self.fgcolor, title='请选择颜色') print(c) # c的值 ((128.5, 255.99609375, 0.0), '#80ff00') self.fgcolor = c[1] self.pencountflag=False elif name==&quot;choose&quot;: self.drawpad.bind('&lt;B1-Motion&gt;', self.choose_and_move) self.pencountflag=False elif name=='fill': self.drawpad.bind('&lt;Button-1&gt;', self.floodfill) self.start_fill=True self.pencountflag=False def startDraw(self, event): self.drawpad.delete(self.lastdraw) self.coordsrect=[] self.x11=0 self.y11=0 self.j=0 if self.start_flag: self.start_flag = False self.x = self.drawpad.canvasx(event.x) self.y = self.drawpad.canvasy(event.y) def stopDraw(self, event): self.start_flag = True self.lastdraw = 0 if self.pencountflag: self.pencount=self.pencount+1 def myline(self, event): self.startDraw(event) self.lastdraw = self.drawpad.create_line(self.x, self.y, self.drawpad.canvasx(event.x), self.drawpad.canvasy(event.y), fill=self.fgcolor,width=self.thickness) self.stack() def myline_arrow(self, event): self.startDraw(event) self.lastdraw = self.drawpad.create_line(self.x, self.y, self.drawpad.canvasx(event.x),self.drawpad.canvasy(event.y), arrow=LAST, fill=self.fgcolor,width=self.thickness) self.stack() def myrect(self, event): #print('f') self.startDraw(event) self.lastdraw = self.drawpad.create_rectangle(self.x, self.y, self.drawpad.canvasx(event.x), self.drawpad.canvasy(event.y), outline=self.fgcolor,width=self.thickness) self.stack() def myoval(self, event): self.startDraw(event) self.lastdraw = self.drawpad.create_oval(self.x, self.y, self.drawpad.canvasx(event.x), self.drawpad.canvasy(event.y), outline=self.fgcolor,width=self.thickness) self.stack() def mycircle(self, event): self.startDraw(event) self.lastdraw = self.drawpad.create_oval(self.x, self.y, self.drawpad.canvasx(event.x), self.y+(self.drawpad.canvasx(event.x)-self.x), outline=self.fgcolor,width=self.thickness) self.stack() def mypen(self, event): self.startDraw(event) #print('self.x=', self.x, ',self.y=', self.y) self.w=self.drawpad.create_line(self.x, self.y, self.drawpad.canvasx(event.x), self.drawpad.canvasy(event.y), fill=self.fgcolor,capstyle=&quot;round&quot;,width=self.thickness) self.penonly=self.w self.x = self.drawpad.canvasx(event.x) self.y = self.drawpad.canvasy(event.y) self.stack() self.stack_pen() def myerasor(self, event): self.startDraw(event) self.w=self.drawpad.create_line(self.x, self.y, self.drawpad.canvasx(event.x), self.drawpad.canvasy(event.y), fill=col_1[1],width=self.thickness,capstyle=&quot;round&quot;) self.x = self.drawpad.canvasx(event.x) self.y = self.drawpad.canvasy(event.y) self.stack() def hotKey(self, event): c = event.char if c == 'r': self.fgcolor = 'red' elif c == 'g': self.fgcolor = 'green' elif c == 'b': self.fgcolor = 'blue' elif c == 'y': self.fgcolor = 'yellow' def createtext(self, event): if self.start_flag_text: self.startDraw(event) global i i=i+1 print(i) if i%2==1: self.x1=self.x self.y1=self.y elif i%2==0: a=len(self.text)**(0.8) self.x2=self.x self.y2=self.y self.deltax=(self.x2-self.x1)**(0.9) self.deltay=self.y1-self.y2 self.meanx=(self.x1+self.x2)/2 self.meany=(self.y1+self.y2)/2 self.size=round(self.deltax/a) self.w=self.drawpad.create_text(self.meanx,self.meany,text=self.text,fill=self.fgcolor,font=('Times', self.size, 'bold italic')) self.stack() self.start_flag_text=False def putpic(self,event): if self.start_flag_pic: self.photo_o = PIL.Image.open(self.file_path) w=round(int(self.photo_o.width)*float(self.ratio)) h=round(int(self.photo_o.height)*float(self.ratio)) self.photo_o = self.photo_o.resize((w,h)) # 将图片大小转换为（width，height）200x300大小 file_path_list=list(self.file_path) del file_path_list[-4:-1] self.fp=&quot;&quot;.join(file_path_list)+'.gif' print(self.fp) self.photo_o.save(self.fp) self.startDraw(event) self.x= self.drawpad.canvasx(event.x) self.y= self.drawpad.canvasy(event.y) print(self.x) global photo_1 photo_1= tk.PhotoImage(file=self.fp) self.w=self.drawpad.create_image(self.x, self.y,image=photo_1) self.stack() self.start_flag_pic=False def choose_and_move(self,event): self.startDraw(event) self.lastdraw = self.drawpad.create_rectangle(self.x, self.y, self.drawpad.canvasx(event.x), self.drawpad.canvasy(event.y),dash=(3,5),outline='grey') self.coordsrect.append(self.drawpad.coords(self.lastdraw)) print(self.coordsrect) coords_cho=self.coordsrect[-1] x1=coords_cho[0] y1=coords_cho[1] x2=coords_cho[2] y2=coords_cho[3] self.item_cho=self.drawpad.find_enclosed(x1, y1, x2, y2) self.stack_1() def movethechosen(self,event): for i in range(len(self.chosenlist)): self.drawpad.delete(self.chosenlist.pop(-1)) if self.coordsrect: self.j=self.j+1 if self.j%2==1: self.x11=self.drawpad.canvasx(event.x) self.y11=self.drawpad.canvasy(event.y) else: a=len(self.item_cho) self.delx=(ScaleFactor/75)*(self.drawpad.canvasx(event.x)-self.x11) self.dely=(ScaleFactor/75)*(self.drawpad.canvasy(event.y)-self.y11) for i in range(a): self.drawpad.move(self.item_cho[i-1],self.delx,self.dely) else: None def floodfill(self,event): self.startDraw(event) if self.start_fill: coord_pen=[] a=len(self.penmarklist) for k in range(a): coord_pen.append(self.drawpad.coords(self.penmarklist[k-1])) b=len(coord_pen) c=np.array(coord_pen) x=(c[:,0]+c[:,2])/2 y=(c[:,1]+c[:,3])/2 for i in range(b): x[i-1]=self.drawpad.canvasx(x[i-1]) y[i-1]=self.drawpad.canvasy(y[i-1]) self.xfill=self.drawpad.canvasx(event.x) self.yfill=self.drawpad.canvasy(event.y) delx=x-self.xfill dely=y-self.yfill eps=10**(-8) x=np.array(x) y=np.array(y) xy=np.concatenate((x,y),axis=0) xy=xy.reshape(2,-1).T print(xy) x_avil=[] y_avil=[] center=[self.xfill,self.yfill] r_list=[] theta_list=[] for i in range(len(x)): x_1=xy[i-1,:] r=math.sqrt(math.pow(x_1[0]-center[0],2)+math.pow(x_1[1]-center[1],2)) theta=math.atan2(x_1[1]-center[1],x_1[0]-center[0])/math.pi*180#转换为角度 if theta&lt;0: theta=360+theta r_list.append(r) theta_list.append(theta) print(theta_list) theta_r=np.concatenate((theta_list,r_list),axis=0) theta_r=theta_r.reshape(2,-1).T print(theta_r) num_clusters = self.pencount estimator = KMeans(n_clusters=num_clusters) estimator.fit(xy)#聚类 label_pred = estimator.labels_ #获取聚类标签 centroids = estimator.cluster_centers_ #获取聚类中心 inertia = estimator.inertia_ # 获 print(centroids) print((centroids-np.array([self.xfill, self.yfill]))**2) a=np.argsort(np.sum((centroids-np.array([self.xfill ,self.yfill]).T)**2)) num=a[0] for i in range(len(x)-1): if label_pred[i-1]==num: x_avil.append(x[i-1]) y_avil.append(y[i-1]) print(num) for i in range(len(x_avil)-1): for k in range(len(x_avil)-1): self.w=self.drawpad.create_line(x_avil[i-1], y_avil[i-1], x_avil[k-1], y_avil[k-1] , fill=self.fgcolor,width=20) self.stack() self.start_fill= False def stack(self): #对于撤回功能的栈 if self.w == None: self.stlist.append(self.lastdraw) else: self.stlist.append(self.lastdraw) self.stlist.append(self.w) def stack_1(self): #对于撤回功能的栈 if self.w == None: self.chosenlist.append(self.lastdraw) else: self.chosenlist.append(self.lastdraw) self.chosenlist.append(self.w) def stack_pen(self): self.penmarklist.append(self.penonly) def callback(self,event): #print(self.stlist) for i in range(5): self.drawpad.delete(self.stlist.pop(-i)) def get_pic(pic_code, pic_name): image = open(pic_name, 'wb') image.write(b64decode(pic_code)) image.close() def newdraw(): def askcolor_1(): global col_1 quest.attributes(&quot;-topmost&quot;, False) col_1=askcolor(color='black', title='请选择颜色') quest.attributes(&quot;-topmost&quot;, True) #新建画布 def confirm_1(): global width_b global height_b width_b = int(drawboard_w.get()) height_b = int(drawboard_h.get()) quest.destroy() #画板外框宽 wid=width_b hei=height_b+50 root.state('icon') draw= Toplevel() draw.geometry(&quot;%dx%d&quot; % (wid,hei)) app = Application(master=draw) draw.mainloop() def cancel_1(): quest.destroy() quest = tk.Toplevel(root) quest.title('画布设置') quest.geometry('500x300') drawboard_w = tk.StringVar() drawboard_w.set('1920') tk.Label(quest, text='画布长度 ').place(x=20, y=20) entry_w = tk.Entry(quest, textvariable=drawboard_w) entry_w.place(x=130, y=20) drawboard_h = tk.StringVar() drawboard_h.set('1080') tk.Label(quest, text='画布高度 ').place(x=20, y=70) entry_h= tk.Entry(quest, textvariable=drawboard_h) entry_h.place(x=130, y=70) color_c = tk.Button(quest, text='选择画布颜色', command=askcolor_1) color_c.place(x=20, y=120) confirm = tk.Button(quest, text='新建画布', command=confirm_1) confirm.place(x=200,y=220) cancel = tk.Button(quest, text='取消', command=cancel_1) cancel.place(x=400,y=220) #draw= Tk() #draw.geometry(&quot;%dx%d&quot; % (win_width, win_height)) #app = Application(master=draw) #draw.mainloop() def browser(): webbrowser.open('https://drawingsword.com/post/hua-tu-ruan-jian-shi-yong-zhi-nan/') #创建主菜单 root.title(&quot;画图（design by zhu sir）&quot;) root.geometry(&quot;%dx%d&quot; % (win_width, win_height)) menubar = tk.Menu(root) #新画板菜单栏 filemenu = tk.Menu(menubar,tearoff=0) menubar.add_cascade(label='画图', menu=filemenu) filemenu.add_command(label='新画板', command = newdraw) filemenu.add_command(label='保存', command= None) #设置菜单栏 settingmenu = tk.Menu(menubar, tearoff=0) menubar.add_cascade(label='设置', menu=settingmenu) settingmenu.add_command(label='快捷键', command = None) #帮助菜单栏 helpmenu = tk.Menu(menubar, tearoff=0) menubar.add_cascade(label='帮助', menu=helpmenu) helpmenu.add_command(label=&quot;软件使用指南&quot;, command = browser) a=random.randint(1,3) name=&quot;bizhi&quot;+str(a)+'_gif' filename=&quot;bizhi&quot;+str(a)+'.gif' get_pic(eval(name), filename) #增加背景图片 photo = tk.PhotoImage(file=filename) theLabel = tk.Label(root,text =&quot;新建画布以开始&quot;,justify=tk.LEFT,image=photo,compound = tk.CENTER,font=(&quot;微软雅黑light&quot;,50),fg = &quot;white&quot;) theLabel.pack() root.config(menu=menubar) root.mainloop() ","link":"https://tomzhu0225.github.io/post/hua-tu-ruan-jian-shi-yong-zhi-nan/"},{"title":"算法女孩","content":"科普小说连载中…… ","link":"https://tomzhu0225.github.io/post/fiction/"},{"title":"Fully automatic AI player in the fps game","content":"The passage will be updated in the long run and If you have any idea or you've examined any grammar mistake in the passage, feel free to leave a comment ","link":"https://tomzhu0225.github.io/post/fully-automatic-ai-player-in-the-fps-game/"},{"title":"随机生成的噪声图像中识别特定特征（完整版）","content":" 12.27 进行了若干修改，增加在前面的话，增加逻辑斯蒂分类器设计；遗憾的是通过笔者的多次实验，这样的方法并不能很好的从随机矩阵中学习，来分辨特定的随机矩阵。就在刚才我想到了吴恩达教授的一句至理名言：人做不到的事情，就不要妄想机器学习和神经网络来做到！ 12.30 大结局，编写完成求解器，在附录增加完整的代码。和大家聊一聊! ","link":"https://tomzhu0225.github.io/post/sui-ji-sheng-cheng-de-zao-sheng-tu-xiang-zhong-shi-bie-te-ding-te-zheng-geng-xin-ri-zhi/"},{"title":"本站知识共享协议（CC协议）","content":" 署名-非商业性使用-相同方式共享 4.0 国际版 (CC BY-NC-SA 4.0) *这是一份非官方、未本地化的翻译文本，仅供参考。 这是一份易于普通人阅读与理解的许可证文本（并非法律性质的授权条款的替代内容）。 你可以自由地： 分享 – 在任何媒介或格式下再分发、传播本创作。 修改 – 重混、转换、依据本创作进行再创作。 只要遵守下述条款规定，授权人将不能撤回你使用本创作的自由。 唯须遵循以下条款： 署名 – 你必须以给予姓名标注，并提供本许可证的链接。同时你需要声明公开的创作是否经过修改。你可以采用恰当的形式将相关信息表述出来，但不得以任何形式暗示授权人已正式认可了你以及你的使用行为。 非商业性 – 你不得将本创作运用于商业目的。 相同方式共享 – 如果你对本创作进行了重混、转换、依据本创作进行再创作，你必须依据本创作采用的许可证来分发你的创作。 不得增加额外限制 – 你不能增设任何法律限制或是技术限制，来限制他人进行本许可证已经允许的行为。 声明： 当你使用本创作中属于公众领域的元素，或当法律有额外或限制条款允许你的使用行为时，则你不需要遵守本授权协议。 不提供保证。本授权协议并不能完全提供你预期需要的所有许可，例如：公共形象权，隐私权，著作人身权等其他权利，这些权利的法律限制可能会限制你使用本创作。 ","link":"https://tomzhu0225.github.io/post/ben-zhan-zhi-shi-gong-xiang-xie-yi-cc-xie-yi/"},{"title":"转子发动机建模日志！（14/12日更新）","content":"自己解决问题真的很爽！综合运用数学物理matlab以及inventor解决问题！（14/12更新） 2020/12/14 在实际应用建模中，我们团队遇到了问题。转子发动机的转子部分是绕着一个固定的太阳轮做旋转运动，转子不但绕定子做公转，而且因两个齿轮传动比的作用，转子也自己做自转运动，这就导致转子的中心距最大的三点（转子的三个顶点）的运动包络线不是一个单纯的由圆弧和直线构成的简单图形。事实上我的小组成员在对着已有模型建模时候就出现了问题，对于已有模型的缸盖的测量太过复杂，曲率等太多根本无法有效的复原转子的缸壁形状。 在今天早晨的数学实验课上，数学老师让我们自行探索matlab软件的相关命令，而我之前因为学过一点ML课程，对matlab还算熟悉，再加上我主张个人对于编程软件的命令的态度是并不需要完全掌握，像很多知识一样，只要你知道matlab可以实现这个功能，对于其具体的实现方法你总是可以用“面向百度编程”的方法解决。我的信条是数学是为了实际应用服务的，于是在课上我想转子顶点的运动过程这个实际上我的团队面对的工程问题一定很有趣。要想研究转子顶点的轨迹那我们一定要将其进行抽象化，变成可以用数学语言描述的问题。 而手头的matlab软件可以可视化的，可以让我立刻了解我试想的函数（参数）方程的模样，接着我可以将函数图像，与inventor软件模拟的外形相比对（大概是一个八字形），这样我就可以验证我的模型的正确与否。而实际的验证过程并不是一番风顺的，最开始我主观的忽略了齿轮传动比的影响，认为转子自转的角度和公转的角度相等，这样的模型求出来的图像自然是不对的，具体来说是一个椭圆（而这个椭圆甚至不是对称图形）；模型出现了错误，自然需要修正模型，而另一个问题出现了，对于一个没有学习过机械原理的大一学生来讲，我该如何知道一个转动比为1.5的行星齿轮组，各自旋转的比例呢？他们各自自转的角度的比例是3：2吗？我重新计算，但是函数输出仍然和真实模型相差甚远。（甚至于我也并不清楚传动比是什么概念，仅仅传动比就决定了两个齿轮各自旋转的角度了吗，那圆心距，两个齿轮直径呢？）我退而求其次观察inventor中已经建模好的模型 模型中我已经进行了约束，而我完全可以观察在inventor仿真中两个齿轮的各自旋转的比例。我观察到旋转的比例大概是1：3（当两个齿轮的接触点旋转theta时，转子自转1/3*theta）。接下来就是验证，我在matlab里输入再次计算的结果 图形奇迹般的和真实情况吻合。但是如何将这个函数输入到inventor的草图中来进行拉伸建模进而和已知模型对比来进一步确认真实性呢？这时候我的脑子里其实已经有了两种预案，首先如果inventor中有直接输入函数的功能那就很方便，如若没有或许我们就得把函数分成多个数据点来输入inventor,用小直线段来近似曲线。经过我的一番搜索，inventor在2013年加入了函数草图的功能，这样我就可以直接输入函数了！ 有意思的一点是我们设计参照的原模型似乎就是在2013之前建模完成的，作者使用的就是细分为直线段建的模！这样导致缸体内壁并不平整，在之前我对已有模型做力学仿真的时候做的极不顺利，仿真根本没法进行下去。而新方法在力学仿真里效果如何还得之后去验证。 写这些不是为了炫耀我的思想多么严谨，而是我认为这种研究问题的方法是很有价值的，在这个新的时代人早就不能穷尽所有知识了，我们做的是在自己已有知识的基础上，充分利用外界的软件，互联网，自己直觉上的猜想，来验证自己想要解决的问题。我们站在巨人的肩膀上！ 2020/12/6 怎么说转子发动机一直是我的梦想吧，毕竟弱者打败强者的故事不论何时都不过时，马自达在1991年的勒芒比赛中Mazda 787B 凭借着转子发动机赢得了勒芒比赛的总冠军，成为历史上唯一夺得过勒芒24小时耐力赛总冠军的亚洲厂商，以至于第二年国际汽联不惜动用手段禁止转子发动机参赛！这种凭借着个人能力而让规则不惜做出改变也要扼杀的，是多么的年少轻狂。多年以来纵然转子发动机有诸多缺陷，马自达从未停止改良她的脚步，在其他技术领域马自达也总是最另类的那一批：创驰蓝天，均质压燃......电动机当道，纵然知道最终要消亡，汽油机总要发出最后的一声低吼，压榨出最后一丝潜力，让世人知道汽油机永不为奴！卖车挣钱，花钱搞转子，没钱再卖车，马自达的工程师和高层一定有发自内心的热爱！时间不多，我先写这么多，思绪甚是杂乱，来日再梳理。 ","link":"https://tomzhu0225.github.io/post/ji-jiang-jian-mo-wan-cheng-de-zhuan-zi-fa-dong-ji/"},{"title":"网站使用指南（评论系统开启！）","content":"大家评论要遵守社会主义价值规范哦 一. 界面功能 在网页版的页面的右上角，或者手机版的下拉菜单中会找到3枚菜单：首页、归档、标签。 首页按钮会带你来到主界面，其中展示的文章是按照时间发布顺序排序的。 归档按钮会来到一个页面展示了文章的初始发布时间线。 标签按钮会出现几个标签，文章大多数按照标签所示分类，可以按需引索。 同时网站本身也带有文章的关键字的搜索功能。 关于按钮 第一次入站请一定要看关于！ 二. 评论功能 每篇文章都有评论功能，请善用这个功能。互联网非法外之地。 在评论时请填写自己的昵称（我的老熟人就用一个我能认出来的昵称吧），邮箱。 三. 文章加载 请尽量不要用手机中的微信或者qq自带浏览器打开这个网页，而应使用独立浏览器打开。要得到最佳的使用体验请用电脑浏览。因为网站使用的是境外服务器一些带有图片的文章可能加载较慢，请坐和放宽耐心等待。 四. 写作 文章都使用markdown语法写作，但是我目前并没有学习markdown语法，所以文章版面朴实无华，这一点会在日后改变。数学类的文章我用latex写作，但是不知道是否可以将tex文件直接上传进行编译，所以暂时的解决办法是转换成图片上传（加载较慢） ","link":"https://tomzhu0225.github.io/post/ping-lun-xi-tong-kai-qi/"},{"title":"以惯性约束聚变为推进方式的深空殖民探索方案","content":"因为是结课作业也别想什么严谨了，大家看个乐呵就行。 ","link":"https://tomzhu0225.github.io/post/yi-guan-xing-yue-shu-ju-bian-wei-tui-jin-fang-shi-de-shen-kong-zhi-min-tan-suo-fang-an/"},{"title":"Bonjour à tous!","content":"Bonjour à tous. Je m'appelle Zhu bowen et Je suis chinoise. Je viens du Liaoning, une province au Nord-est de la chine. Plus précisement de Dalian. C'est tré bel ville, il y a mer a trois côte partout du ville. il est appeler la gemme dan la est au chine. Quand j'etai petit, j'ai entendu que le françai est tré rigoureux et extremement grâse. Plus important, le Réacteur thermonuclaire expérimental International étre construit en France. Au cas où tu ne le saurais pas. Je suis un passionné de voitures et il y a beaucoup de constructeurs automobiles fameux, par exemple Renault, peugeot , citroën et autre. En résumé, J'espère pouvoir un jour me rendre en france pour des échanges d'études et J'espère pouvoir un jour que je pourrai corriger la légende de ce texte! ","link":"https://tomzhu0225.github.io/post/bonjour-a-tous/"},{"title":"一种高阶常系数齐次微分方程的解法及微分方程的相空间理解方法","content":" ","link":"https://tomzhu0225.github.io/post/mAtH001/"},{"title":"关于","content":" 欢迎来到我的小站呀，很高兴遇见你！🤝 关于本站： 这是一个关于表达，记录技术灵感，最终实现个人梦想的网站。 因为希望实现论文、数据的共享，建立一个开放自由的学术环境，我的论文（作业）、我的经验的总结、那些我下大功夫才弄懂的事情都会在这个网站进行发布共享，而这些东西如果我不说出来就亏大了，也希望可以帮到更多的人，而关于共享的协议将在稍后更新(如果还没有只能说这个人实在没时间弄)； 我因为一套名叫《数学女孩》的科普书籍成为了今天的自己，这套书我从初中读到大学仍然没有穷尽，独特的叙述和角度为我任何时期的学习都起到了重要的作用，书中提到的研究问题的方法早已成为了我学习时的一般性的准则（这套书值得我为她再写一篇单独的文章）。我明白一本有趣而严谨、内容深厚的科普书籍、文章对一个初中生、高中生甚至大学生有开天辟地一般的作用。而我也希望写出这样的科普书籍，但是我深知我的知识仍然远远的不够厚重来写一本成体系的书籍，如何将小说和科普融合也是一个待探索的问题，这个网站将成为我磨练写作的一块磨刀石，看到文章知识上的偏差或者剧情上的忍俊不禁可能时有发生，请一定要在评论或邮件中指出，这样才能帮助我提升。 作为一个大学生，我时常也有一些奇思妙想，这些东西如果不记录下来，可能也就是转瞬即逝罢了。这些想法有的别人可能已经付出了时间，有点纯属天马行空，有的我甚至会投入时间去完善并且实践想法，希望看到这些想法而有兴趣或者有类似idea的小伙伴与我联系，咱们看看这个到底可不可能实现。 我也是一个二外学习者，学习的是法语。要知道自学一门二外是一个非常困难的事情，在这个网站我会更新一些我用我的法语写的一些文章，这些文章有些表达是我根本没有见过的，也就是有道翻译来的。同时我对动词变位和句型的理解也不深，会有很多说不通的地方，这些文章我会在之后弄懂之后重新修改并且将修改后的文章进行对比的。有也在学习法语的小伙伴联系我！ 博主是谁： 博主是西安交通大学在钱学森班（能动）在读本科生，微软学生大使 兴趣爱好： FUSION，法语，3A大作，量子计算，机器学习，数学，数码硬件，车辆等等 联系我： 邮箱：tomzhu0225@stu.xjtu.edu.cn QQ:2062141317 总之这个网站，我想用来实现我的一些梦想，也想找到一些志同道合的小伙伴。欢迎帮助我将这个网站推广！ ","link":"https://tomzhu0225.github.io/post/about/"},{"title":"早安，全世界","content":"HELLO WORLD ","link":"https://tomzhu0225.github.io/post/zao-an-quan-shi-jie/"}]}